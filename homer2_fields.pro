function segmentB,obs,I,xplus,x	; calculates the magnetic field from a stright wire segment	; obs is the point at which the field is needed	; xplus is the position of the leading tip of the segment	; x is the position of the trailing tip of the segment	; from physics made mecum	; in rowan's office		; find the direction of current	nhat = unit(minus(xplus,x))	; the radius vectors from the tips of the wire	; to the point of observation	r1 = minus(obs,x)	r2 = minus(obs,xplus)		; the unit vectors	r1hat = unit(r1)	r2hat = unit(r2)		; the part of the radius vector perpendicular	; to the direction of current	rperp = cross(nhat,cross(r1,nhat))		; set the direction of the magnetic field	dBhat = unit(cross(nhat,rperp))	; cosines that are needed	cos_p1 = dot(nhat,r1hat)	cos_p2 = dot(nhat,r2hat)	mu0 = 4*!dpi*1E-7	; set the magnitude of the B field	dBmag = mu0/(4*!DPI)*I/mag(rperp)*(cos_p1-cos_p2)		; properly combine the direction and magnitude	result = scale(dBmag,dBhat)	return,resultendfunction rectB,obs,rect	; calculates the magnetic field from a rectangular loop	; by splitting it up into 4 segments	result = {vector,0,0,0}	; get the center and size of the loop	c = rect.center	h = rect.height	w = rect.width	I = rect.j		; find the distances the segments are shifted from the center	d = cross(rect.nhat,{vector,0,0,1})	dx = w/2*d.x	dy = w/2*d.y	dz = h/2	; this next section of code goes through the four segments	; that make up a rectangular loop and properly sets the leading	; and trailng positions of each segment before calculating the	; field from each one, added each field contribution to the total	x = {vector,c.x - dx,c.y - dy,-dz}	xplus = x	xplus.z = xplus.z + 2*dz	result = plus(result,segmentB(obs,I,xplus,x))	x = xplus	xplus.x  = x.x + 2*dx	xplus.y = x.y + 2*dy	result = plus(result,segmentB(obs,I,xplus,x))	x = xplus	xplus.z = x.z - 2*dz	result = plus(result,segmentB(obs,I,xplus,x))	x = xplus	xplus.x = x.x -2*dx	xplus.y = x.y - 2*dy	result = plus(result,segmentB(obs,I,xplus,x))	return,resultendfunction circB,obs,circ	; this calculates the magnetic field from a circular 	; current loop.  see Blewett's paper for details.		result = {vector,0,0,0}	c = circ.center	a = circ.radius		; get radius relative to loops center	r = minus(obs,c)	z = r.z		; cylindrical coordinate - distance to axis of loops	rho = sqrt(r.x^2.0+r.y^2.0)		; common factor used a few times in field expressions	mu0 = 4.0*!pi*1.0E-7	common1 = (a+rho)^2.0+z^2.0    common2 = common1 - 4*rho*a	outfront = mu0*circ.j/(2.0*!pi*sqrt(common1))	numere = a*a - rho*rho - z*z	denom = (a-rho)^2.0 + z*z	numerk = a*a + rho*rho + z*z	; compute the complete ellitical integrals of modulus k2	;match to the elll1 and ell2 computation tools	k2 = 4*a*rho/common1	ell1 = K(sqrt(k2))	ell2 = E(sqrt(k2))		; magnitudes of the rho and z components of the field	Bzhat_mag = outfront*(ell1 + ell2*numere/denom)	if rho lt 0.001 then begin	  Brho_mag = 0.0	  result.x = 0.0	  result.y = 0.0	endif else begin	  Brho_mag = outfront*(z/rho)*(-ell1+(numerk/denom)*ell2)	  result.x = Brho_mag*r.x/sqrt(r.x*r.x+r.y*r.y)	  result.y = Brho_mag*r.y/sqrt(r.x*r.x+r.y*r.y)	endelse	result.z = Bzhat_mag 		return,resultendfunction rectsB,obs,geom	; this function goes through all the rectangular coils and adds	; up the contribution to the field from each	result = {vector,0,0,0}	for i=0,geom.nrects-1 do begin		result = plus(result,rectB(obs,geom.rect[i]))	endfor	return,resultendfunction circsB,obs,geom	; this function goes through all the circular coils and adds	; up the contribution to the field from each	result = {vector,0,0,0}	for i=0,geom.ncircs-1 do begin		result = plus(result,circB(obs,geom.circ[i]))	endfor	return,resultendfunction B,obs,geom	; adds the fields from the rectangular and circular coils	return,plus(rectsB(obs,geom),circsB(obs,geom))end